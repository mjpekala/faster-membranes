% Experiment to determine how far we can push the 
% subsampling+inpainting approach.

addpath('./inpaint');
addpath('./tight_subplot');

% Parameters
param=struct();
param.emFile = '../Data/ISBI2012/ISBI_Train20/Xvalid.mat';
param.truthFile = '../Data/ISBI2012/ISBI_Train20/Yvalid.mat';
param.z = 1;  % which slice to use for visualization
param.interactive = 0;

param.pctToTry = [.25 .5 .6:.05:.95];

%-------------------------------------------------------------------------------
%% Load data

% load membrane probabilities generated by Caffe
if param.interactive
  [fn,path] = uigetfile('*.mat', 'Select CNN output for ISBI validation data');
  load(fullfile(path, fn));
else
  fn = '../Models/lenet/ISBI_Train20/YhatDeploy.mat';
  load(fn);
end


Yhat = squeeze(Yhat(2,:,:,:));
Yhat = permute(Yhat, [2 3 1]);  % python -> matlab ordering

% XXX: This currently assumes all estimates of -1 are non-membrane.
% Note that in the future this may not be true (once we actually
% start evaluating only a subset of the model).
Yhat(Yhat==-1) = 0;  % needs to be based on X volume instead!


% load the ground truth
load(param.emFile);
Xvalid = permute(Xvalid, [2 3 1]);  % python -> matlab ordering
Xvalid = 255-Xvalid;
load(param.truthFile);
Yvalid = permute(Yvalid, [2 3 1]);  % python -> matlab ordering


% show performance of original estimates
[fpr, recall, precision] = perfcurve2(Yvalid, Yhat);
figure(1);
plot(fpr, recall); grid on;
xlabel('FPR'); ylabel('TPR');
title('pixel-level classification performance');

% visualize estimates for one slice
figure('Position', [200 200 1200 400]);
ha = tight_subplot(1, 3, [.03, .03]);

axes(ha(1));
imagesc(Xvalid(:,:,param.z));
title(sprintf('data; slice %d', param.z))
set(gca, 'Xtick', [], 'Ytick', []);

axes(ha(2));
imagesc(Yvalid(:,:,param.z));
title(sprintf('ground truth; slice %d', param.z))
set(gca, 'Xtick', [], 'Ytick', []);

axes(ha(3));
imagesc(Yhat(:,:,param.z));
title(sprintf('CNN probabilities; slice %d', param.z))
set(gca, 'Xtick', [], 'Ytick', []);
linkaxes([ha(1) ha(2)], 'xy');


if param.interactive
  button = questdlg('Do you want to run the inpainting analysis?');
  if strcmp(button,'No'), return; end
end


%-------------------------------------------------------------------------------
%% Run the analysis

pctOmitted = [];
err = [];
runtime = [];


for pct = param.pctToTry;
  fprintf('[info]: for deletion percent: %0.2f\n', pct)

  % do this per-slice for now 
  % (perhaps better to do in 3d, but then many "collisions")
  p = sobolset(2);
  nToKill = pct*size(Yhat,1)*size(Yhat,2);
  P = p(1:nToKill,:);
  P = floor(bsxfun(@times, P, [size(Yhat,1), size(Yhat,2)])) + 1;
  ind = sub2ind(size(Yhat(:,:,1)), P(:,1), P(:,2));
  
  % mask out pixels 
  Ycnn = zeros(size(Yhat));
  Yrepaired = zeros(size(Yhat));
 
  % inpaint
  % inpainting in 3d seems slower...TODO: test this - I may have
  % not waited long enough...
  tic
  for ii = 1:size(Yhat,3)
      Yi = Yhat(:,:,ii);
      Yi(ind) = NaN; % simulate not evaluating these pixels w/ CNN
     
      % inpaint and rescale back to [0 1]
      Yr = inpaintn(Yi);
      Yr = Yr - min(Yr(:));
      Yr = Yr / (max(Yr(:)) - min(Yr(:)));

      if 1
          Yr(isfinite(Yi)) = Yi(isfinite(Yi));
      end
      
      Ycnn(:,:,ii) = Yi; 
      Yrepaired(:,:,ii) = Yr;
      
      fprintf('done slice %d; total time: %0.2f sec\n', ii, toc);
  end

  %----------------------------------------
  % collect some metrics
  %----------------------------------------
  runtime = [runtime toc];

  tmp = (Yrepaired - Yhat).^2;  
  err = [err sum(tmp(:))];

  nKilled = sum(isnan(Ycnn(:)));
  pctOmitted = nKilled / numel(Ycnn);

  %----------------------------------------
  % visualize
  %----------------------------------------
  figure('Position', [200 200 800 800]);
  ha = tight_subplot(2, 2, [.03, .03]);

  axes(ha(1));
  imagesc(Yvalid(:,:,param.z));
  title(sprintf('slice: %d, truth', param.z));
  set(gca, 'Xtick', [], 'Ytick', []);
  
  axes(ha(2));
  imagesc(Yhat(:,:,param.z));
  title(sprintf('full CNN estimate', param.z));
  set(gca, 'Xtick', [], 'Ytick', []);
  
  axes(ha(3));
  imagesc(Ycnn(:,:,param.z));
  title(sprintf('without %0.2f%%', 100*nKilled/numel(Yhat)));
  set(gca, 'Xtick', [], 'Ytick', []);
  
  axes(ha(4));
  imagesc(Yrepaired(:,:,param.z));
  title(sprintf('inpainted; error: %0.2f', err(end)));
  set(gca, 'Xtick', [], 'Ytick', []);
  linkaxes([ha(1) ha(2) ha(3)], 'xy');
  
 
  % also classification performance
  [fpr, recall, precision] = perfcurve2(Yvalid, Yrepaired);
  figure(1);
  hold on; plot(fpr, recall); hold off;
  
  drawnow;
end


%-------------------------------------------------------------------------------
%% summary graphs

figure(1);
lStr = cellfun(@num2str, num2cell([0 pctOmitted]), 'UniformOutput', 0);
legend(lStr, 'Location', 'SouthEast');


figure;
plot(pctOmitted, err, '-o'); grid on;
xlabel('percentage corrupted');  ylabel('error');
title('reconstruction performance');

figure;
plot(pctOmitted, runtime, '-o'); grid on;
xlabel('percentage corrupted');  ylabel('reconstruction time (sec)');
title('runtime');


