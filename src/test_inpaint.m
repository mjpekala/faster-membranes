% Experiment to determine how far we can push the 
% subsampling+inpainting approach.

addpath('./inpaint');

%-------------------------------------------------------------------------------
% Load the membrane probabilities generated by Caffe
%-------------------------------------------------------------------------------
load('../Models/lenet/ISBI_Train20/YhatDeploy.mat');
Yhat = squeeze(Yhat(2,:,:,:));
Yhat = permute(Yhat, [2 3 1]);  % python -> matlab ordering

% XXX: This currently assumes all estimates of -1 are non-membrane.
% Note that in the future this may not be true (once we actually
% start evaluating only a subset of the model).
Yhat(Yhat==-1) = 0;  % needs to be based on X volume instead!


%-------------------------------------------------------------------------------
% load the ground truth
%-------------------------------------------------------------------------------
load('../Data/ISBI2012/ISBI_Train20/Yvalid.mat')
Yvalid = permute(Yvalid, [2 3 1]);  % python -> matlab ordering


[fpr, recall, precision] = perfcurve2(Yvalid, Yhat);
figure;
plot(fpr, recall); grid on;
xlabel('FPR'); ylabel('TPR');
title('original estimates');
drawnow;



%-------------------------------------------------------------------------------
% Run the analysis
%-------------------------------------------------------------------------------
pToTry = [.1 .25 .5 .6:.05:.95];
err = [];
runtime = [];


for pct = pToTry;
  fprintf('[info]: for deletion percent: %0.2f\n', pct)

  % do this per-slice for now 
  % (perhaps better to do in 3d, but then many "collisions")
  p = sobolset(2);
  nToKill = pct*size(Yhat,1)*size(Yhat,2);
  P = p(1:nToKill,:);
  P = floor(bsxfun(@times, P, [size(Yhat,1), size(Yhat,2)])) + 1;
  ind = sub2ind(size(Yhat(:,:,1)), P(:,1), P(:,2));
  
  % mask out pixels 
  Ycnn = zeros(size(Yhat));
  Yrepaired = zeros(size(Yhat));
 
  % inpaint
  % inpainting in 3d seems slower...TODO: test this - I may have
  % not waited long enough...
  tic
  for ii = 1:size(Yhat,3)
      Yi = Yhat(:,:,ii);
      Yi(ind) = NaN; % simulate not evaluating these pixels w/ CNN
     
      % inpaint and rescale back to [0 1]
      Yr = inpaintn(Yi);
      Yr = Yr - min(Yr(:));
      Yr = Yr / (max(Yr(:)) - min(Yr(:)));

      if 1
          Yr(isfinite(Yi)) = Yi(isfinite(Yi));
      end
      
      Ycnn(:,:,ii) = Yi; 
      Yrepaired(:,:,ii) = Yr;
      
      fprintf('done slice %d; total time: %0.2f sec\n', ii, toc);
  end
  runtime = [runtime toc];

  nKilled = sum(isnan(Ycnn(:)));

  %----------------------------------------
  % visualize
  %----------------------------------------
  figure('Position', [200 200 1200 400]);
  ha = tight_subplot(1, 3, [.03, .03]);
  z = 10;

  axes(ha(1));
  imagesc(Yhat(:,:,z));
  title(sprintf('slice: %d, full estimate', z));
  set(gca, 'Xtick', [], 'Ytick', []);
  
  axes(ha(2));
  imagesc(Ycnn(:,:,z));
  title(sprintf('without %0.2f%%', 100*nKilled/numel(Yhat)));
  set(gca, 'Xtick', [], 'Ytick', []);
  
  axes(ha(3));
  imagesc(Yrepaired(:,:,z));
  tmp = (Yrepaired - Yhat).^2;  err = [err sum(tmp(:))];
  title(sprintf('inpainted; error: %0.2f', err(end)));
  set(gca, 'Xtick', [], 'Ytick', []);
  linkaxes([ha(1) ha(2) ha(3)], 'xy');
  
 
  % also performance
  [fpr, recall, precision] = perfcurve2(Yvalid, Yrepaired);
  figure;
  plot(fpr, recall); grid on;
  xlabel('FPR'); ylabel('TPR');
  title(sprintf('without %0.2f%%', 100*nKilled/numel(Yhat)));
  
  drawnow;
end

figure;
plot(pToTry, err, '-o'); grid on;
xlabel('percentage corrupted');  ylabel('error');
title('reconstruction performance');

figure;
plot(pToTry, runtime, '-o'); grid on;
xlabel('percentage corrupted');  ylabel('reconstruction time (sec)');
title('runtime');


